(* ::Package:: *)

(*
Copyright: Giovanni Cerchiari, Yannick Weiser
e-mail: giovanni.cerchiari@uibk.ac.at
date : 08/2022
*)
(*This file is a free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This file is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with the other repository files.
    If not, it can be found at <https://www.gnu.org/licenses/>.
*)
(*
-----------------------------------------------------------------------
This file contains the script-program that has been used to evaluate
the results presented in the article:

If you wish to cite this work, we prepared a citation file "selective_suppression.bib"
in bibtex format in the repository.

This file was modified from 
doi: 10.5281/zenodo.4545692
*)
(*
-----------------------------------------------------------------------
The script is written for Mathematica 11.3 .
It was executed sucessfully on a machine with the following specifications
- operating system : Windows 10
- processor : Intel(R) Core(TM) i5-7300U CPU @ 2.60GHz 2.71 GHz
- RAM : 16 GB
-----------------------------------------------------------------------
*)
(*---------------------------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------------------------*)
ClearAll["Global`*"]
Needs["PlotLegends`"]
(*----------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------*)
(*PLOTS*)
(*----------------------------------------------------------------------------------------------*)
(*standard font size for all plots*)
lgdfontsize = 16;
(*frame flag that can be used for all plots*)
frameflg = False;
(*line style spec*)
xyzlinestyle = {Directive[Red, Thick, Dashing[None]], Directive[Green, Thick, Dashing[None]],Directive[Blue, Thick, Dashing[None]],
Directive[Black, Thick, Dashed], Directive[Black, Thick, Dashed],Directive[Blue, Thick, Dashed],
Directive[Orange, Thick, Dashing[None]], Directive[Purple, Thick, Dashing[None]]};
(*----------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------*)
(*SPHERICAL COORDINATES*)
SetCoordinates[Spherical]
(*Generic direction in space*)
nr[\[Theta]_,\[Phi]_]:={Cos[\[Phi]]*Sin[\[Theta]],Sin[\[Phi]]*Sin[\[Theta]],Cos[\[Theta]]};
n\[Theta][\[Theta]_,\[Phi]_]:={Cos[\[Phi]]*Cos[\[Theta]],Sin[\[Phi]]*Cos[\[Theta]],-Sin[\[Theta]]};
n\[Phi][\[Theta]_,\[Phi]_]:={-Sin[\[Phi]],Cos[\[Phi]],0};
Print["Generic direction in space (\[Theta],\[Phi]) = ", MatrixForm[nr[\[Theta],\[Phi]]]]
(*---------------------------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------------------------*)
(*Green's tensor*)
(*The electric field is calculated by
E = -\[Omega]^2 (Gmat.pversor) * Integrate[ p(x)*g(n,x) d3x]
The full calculation to arrive to tensorial Green's function is presented in file "Green_function.wl". Here we just use the results
*)
(*Matrix part of the Green's tensor (shortcut to calculate it)*)
Gmat[\[Theta]_,\[Phi]_]:=Evaluate[FullSimplify[IdentityMatrix[3]+FullSimplify[Grad[Div[IdentityMatrix[3]*Exp[I*(x*x0+y*y0+z*z0)],{x,y,z},"Cartesian"],{x,y,z},"Cartesian"]/Exp[I*(x*x0+y*y0+z*z0)]]/.{x0->Sin[\[Theta]]*Cos[\[Phi]], y0->Sin[\[Theta]]*Sin[\[Phi]], z0->Cos[\[Theta]]}]];
Print["Matrix part of the Green's function = ", MatrixForm[Gmat[\[Theta],\[Phi]]]]
(*Scalar part of the Green's function in the measurement region (free space)*)
gm[\[Theta]k_,\[Phi]k_,\[Theta]0_,\[Phi]0_,\[Theta]_,\[Phi]_,r0_]:=I*\[Omega]*\[Mu]0*(Exp[I*(2*\[Pi]*Rdet/\[Lambda])]/(4*\[Pi]*Rdet))*Exp[I*(2*\[Pi]*r0/\[Lambda])*nr[\[Theta]k,\[Phi]k].nr[\[Theta]0,\[Phi]0]]*Exp[I*(2*\[Pi]*r0/\[Lambda])*nr[\[Theta],\[Phi]].nr[\[Theta]0,\[Phi]0]];
(*Scalar part of the Green's function of the image generated by the hemipherical mirror. It cannot be used directly*)
gi[\[Theta]k_,\[Phi]k_,\[Theta]0_,\[Phi]0_,\[Theta]_,\[Phi]_,\[Rho]_,R_,r0_]:=-I*\[Omega]*\[Mu]0*(Exp[I*(2*\[Pi]*Rdet/\[Lambda])]/(4*\[Pi]*Rdet))*\[Rho]*Exp[I*(2*\[Pi]*r0/\[Lambda])*nr[\[Theta]k,\[Phi]k].nr[\[Theta]0,\[Phi]0]]*Exp[-I*(2*\[Pi]*r0/\[Lambda])*(nr[\[Theta],\[Phi]].nr[\[Theta]0,\[Phi]0]-2*R/r0)];
(*Scalar part of the Green's function in the control region: direct field + image field*)
gc[\[Theta]k_,\[Phi]k_,\[Theta]0_,\[Phi]0_,\[Theta]_,\[Phi]_,r0_]:=Evaluate[Simplify[gm[\[Theta]k,\[Phi]k,\[Theta]0,\[Phi]0,\[Theta],\[Phi],r0]+gi[\[Theta]k,\[Phi]k,\[Theta]0,\[Phi]0,\[Theta],\[Phi],1,\[Lambda],r0]]];
Print["Green's function control region gc = ", gc[\[Theta]k,\[Phi]k,\[Theta]0,\[Phi]0,\[Theta],\[Phi],r0]]
(*Simplify conditions: angles real, wavelenght positive, radius positive*)
simplfyGreenConditions={\[Lambda]>0, \[Theta]>0, \[Phi]>0, \[Phi]0>0, \[Theta]0>0, \[Phi]k>0, \[Theta]k>0, r0>0, R0>0, Rdet>0, \[Omega]>0, \[Mu]0>0};
(*Green's functions to n-th order*)
Print["Expanding the scalar part  of the Greens' functions in series..."]
gmn1[\[Theta]0_,\[Phi]0_,\[Theta]_,\[Phi]_,r0_]:= Evaluate[Simplify[Normal[Series[gm[\[Pi]/2,\[Pi]/2,\[Theta]0,\[Phi]0,\[Theta],\[Phi],r0],{r0,0,1}]], Assumptions->simplfyGreenConditions]];
gcn1[\[Theta]0_,\[Phi]0_,\[Theta]_,\[Phi]_,r0_]:= Evaluate[Simplify[Normal[Series[gc[\[Pi]/2,\[Pi]/2,\[Theta]0,\[Phi]0,\[Theta],\[Phi],r0],{r0,0,1}]], Assumptions->simplfyGreenConditions]];
Print["gm 1st = ", gmn1[\[Theta]0,\[Phi]0,\[Theta],\[Phi],r0]]
Print["gc 1st = ", gcn1[\[Theta]0,\[Phi]0,\[Theta],\[Phi],r0]]
Print["... Greens' functions expanded."]


(*----------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------*)
(*Asymmetries - DISPLACEMENT - VARIANCE operator*)
(*radially symmetric Gaussian density distribution*)
fgauss[x_,y_,z_,\[Sigma]_]:=\[Rho]*Exp[-(x^2+y^2+z^2)/\[Sigma]^2];
(*Gradient in cartesian coordinates*)
Delfgauss[x_,y_,z_,\[Sigma]_]:= Grad[fgauss[x,y,z,\[Sigma]],{x,y,z}];
(*Geometric factor*)
geofgauss[\[Theta]_,\[Phi]_,\[Sigma]_]:=Evaluate[Simplify[Integrate[Integrate[Integrate[Delfgauss[x,y,z,\[Sigma]]*(nr[\[Theta],\[Phi]].{x,y,z}),{x,-Infinity,Infinity}, Assumptions->{Re[\[Sigma]^2]>0}],{y,-Infinity,Infinity}, Assumptions->{Re[\[Sigma]^2]>0}],{z,-Infinity,Infinity}, Assumptions->{Re[\[Sigma]^2]>0}],Assumptions->{\[Sigma]>0}]];
geofgaussscalar[\[Sigma]_]:=Evaluate[FullSimplify[geofgauss[\[Theta],\[Phi],\[Sigma]][[3]]/Cos[\[Theta]]]];
(*---*)
Print["fgauss = ", fgauss[x,y,z,\[Sigma]]]
Print["normalization fgauss = ", Simplify[Integrate[Integrate[Integrate[fgauss[x,y,z,\[Sigma]],{x,-Infinity,Infinity}, Assumptions->{Re[\[Sigma]^2]>0}],{y,-Infinity,Infinity}, Assumptions->{Re[\[Sigma]^2]>0}],{z,-Infinity,Infinity}, Assumptions->{Re[\[Sigma]^2]>0}],Assumptions->{\[Sigma]>0}]];
Print["Geometric factors fgauss = ", geofgaussscalar[\[Sigma]],  MatrixForm[FullSimplify[geofgauss[\[Theta],\[Phi],\[Sigma]]/geofgaussscalar[\[Sigma]]]]]
(*----------------------------------------------*)
(*radially symmetric homogenous density*)
fsphere[r_,r0_]:=\[Rho]*HeavisideTheta[r0-r];
(*Gradient in spherical coordinates*)
Delsphere[r_,\[Theta]_,\[Phi]_,r0_]:= Evaluate[D[fsphere[r,r0],{r,1}]*nr[\[Theta],\[Phi]]];
(*Geometric factor*)
fgeofsphere[r0_,\[Theta]n_,\[Phi]n_]:=Evaluate[Integrate[Integrate[Integrate[r^3*Delsphere[r,\[Theta],\[Phi],r0]*Sin[\[Theta]]*(nr[\[Theta],\[Phi]].nr[\[Theta]n,\[Phi]n]),{r,0,Infinity}, Assumptions->{r0>0}],{\[Phi],0,2*\[Pi]}],{\[Theta],0,\[Pi]/2}]];
fgeofspherescalar[r0_]:=Evaluate[FullSimplify[fgeofsphere[r0,\[Theta],\[Phi]][[3]]/Cos[\[Theta]]]];
(*---*)
Print["Normalization sphere = ", Evaluate[Integrate[Integrate[Integrate[r^2*Sin[\[Theta]]*fsphere[r,r0],{r,0,Infinity}, Assumptions->{r0>0}],{\[Phi],0,2*\[Pi]}],{\[Theta],0,\[Pi]}]]]
Print["fsphere = ", fsphere[r,r0]]
Print["Geometric factor fsphere = ", fgeofspherescalar[r0], MatrixForm[FullSimplify[fgeofsphere[r0,\[Theta],\[Phi]]/fgeofspherescalar[r0]]]]


(*----------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------*)
(*Asymmetries - ROTATION*)
(*Approximating asymmetries with spherical harmonics*)
fr[c_,r_,\[Theta]_,\[Phi]_]:=(2*Sqrt[\[Pi]])^(-1) *(c[[1]]*SphericalHarmonicY[1,-1, \[Theta], \[Phi]]+c[[2]]*SphericalHarmonicY[1, 0, \[Theta], \[Phi]]+c[[3]]*SphericalHarmonicY[1, 1, \[Theta], \[Phi]]);
(*Radial vector in the spherical harmonics basis*)
mr[r_,\[Theta]_,\[Phi]_]:=r*{Sin[\[Theta]]*Exp[I*\[Phi]]/Sqrt[2],Cos[\[Theta]],Sin[\[Theta]]*Exp[-I*\[Phi]]/Sqrt[2]};
(*assumptions for integrals*)
asyassumptions = {c0>0, \[Theta]1>0, \[Phi]>0, \[Phi]1>0, r>0, \[Theta]d>0, \[Theta]a>0, \[Theta]>0, p>0, \[Mu]0>0, Rdet>0, \[Omega]>0, \[Rho]>0, \[Epsilon]0>1, \[Lambda]>0};
(*Show that the zero order of the expansion of the object's shape does not contribute*)
Print["contribution from Y00 = ", Integrate[Integrate[(2*Sqrt[\[Pi]])^(-1)*SphericalHarmonicY[0,0, \[Theta], \[Phi]]*Sin[\[Theta]]*gcn1[\[Theta]0,\[Phi]0,\[Theta],\[Phi],1],{\[Theta],0,\[Pi]}],{\[Phi],0,2*\[Pi]}]]
(*Scattered electric field*)
Ersc[\[Theta]\[Theta]_,\[Phi]\[Phi]_,\[Theta]1_,\[Phi]1_]:=Evaluate[Integrate[Integrate[fr[mr[c0,\[Theta]1,\[Phi]1],r,\[Theta],\[Phi]]*Sin[\[Theta]]*gcn1[\[Theta]n,\[Phi]n,\[Theta],\[Phi],1],{\[Theta],0,\[Pi]}],{\[Phi],0,2*\[Pi]}]/.{\[Theta]n->\[Theta]\[Theta], \[Phi]n->\[Phi]\[Phi]}];
Erxmat[\[Theta]\[Theta]_,\[Phi]\[Phi]_,\[Theta]1_,\[Phi]1_]:=(Gmat[\[Theta]\[Theta],\[Phi]\[Phi]].{-I*\[Omega]*p,0,0});
Erzmat[\[Theta]\[Theta]_,\[Phi]\[Phi]_,\[Theta]1_,\[Phi]1_]:=(Gmat[\[Theta]\[Theta],\[Phi]\[Phi]].{0,0,-I*\[Omega]*p});
Erx[\[Theta]\[Theta]_,\[Phi]\[Phi]_,\[Theta]1_,\[Phi]1_]:=Erxmat[\[Theta]\[Theta],\[Phi]\[Phi],\[Theta]1,\[Phi]1]*Ersc[\[Theta]\[Theta],\[Phi]\[Phi],\[Theta]1,\[Phi]1];
Erz[\[Theta]\[Theta]_,\[Phi]\[Phi]_,\[Theta]1_,\[Phi]1_]:=Erzmat[\[Theta]\[Theta],\[Phi]\[Phi],\[Theta]1,\[Phi]1]*Ersc[\[Theta]\[Theta],\[Phi]\[Phi],\[Theta]1,\[Phi]1];
(*Detected intensity by a differential pixel detector occupying the emtpy half-sphere*)
Pxdetas[\[Theta]_,\[Phi]_,\[Theta]1_,\[Phi]1_]:=Evaluate[Simplify[(Conjugate[Erx[\[Theta],\[Phi],\[Theta]1,\[Phi]1]].Erx[\[Theta],\[Phi],\[Theta]1,\[Phi]1]), Assumptions->asyassumptions]];
Ixrplot[\[Theta]_,\[Phi]_,\[Theta]1_,\[Phi]1_]:=Evaluate[Simplify[Pxdetas[\[Theta],\[Phi],\[Theta]1,\[Phi]1]/.{c0->1, \[Lambda]->1, Rdet->1, \[Mu]0->1, \[Omega]->1, p->1}]];
Pzdetas[\[Theta]_,\[Phi]_,\[Theta]1_,\[Phi]1_]:=Evaluate[Simplify[(Conjugate[Erz[\[Theta],\[Phi],\[Theta]1,\[Phi]1]].Erz[\[Theta],\[Phi],\[Theta]1,\[Phi]1]), Assumptions->asyassumptions]];
Izrplot[\[Theta]_,\[Phi]_,\[Theta]1_,\[Phi]1_]:=Evaluate[Simplify[Pzdetas[\[Theta],\[Phi],\[Theta]1,\[Phi]1]/.{c0->1, \[Lambda]->1, Rdet->1, \[Mu]0->1, \[Omega]->1, p->1}]];
(*How the intensity in the direction of the detector looks like depending on rotation*)
(*----------------*)(*-----PLOTS - Asymmetries - ROTATION----------*)
(*3D axes label*)
xyzlabl = {Style["x",Bold,Black,lgdfontsize],Style["y",Bold,Black,lgdfontsize],Style["I",Bold,Black,lgdfontsize]};
(*Rotations about the x-axis*)
Print["---------------------------"]
Print["Rotation about the x-axis"]
Print["x-polarized light = ", FullSimplify[Pxdetas[\[Theta],\[Phi],\[Theta]a,\[Pi]/2], Assumptions->{\[Theta]>0, \[Phi]>0, \[Theta]a>0, \[Phi]a>0}]]
anixx = Animate[RevolutionPlot3D[Ixrplot[\[Theta],\[Phi],\[Theta]a,\[Pi]/2],{\[Theta],0,\[Pi]/2},{\[Phi],0,2*\[Pi]}, AxesLabel ->xyzlabl],{\[Theta]a,0,\[Pi]},AnimationRunning->False]
Print["z-polarized light = ", FullSimplify[Pzdetas[\[Theta],\[Phi],\[Theta]a,\[Pi]/2], Assumptions->{\[Theta]>0, \[Phi]>0, \[Theta]a>0, \[Phi]a>0}]]
anixz = Animate[RevolutionPlot3D[Izrplot[\[Theta],\[Phi],\[Theta]a,\[Pi]/2],{\[Theta],0,\[Pi]/2},{\[Phi],0,2*\[Pi]}, AxesLabel ->xyzlabl],{\[Theta]a,0,\[Pi]},AnimationRunning->False]
(*Rotations about the y-axis*)
Print["---------------------------"]
Print["Rotation about the y-axis"]
Print["x-polarized light = ", FullSimplify[Pxdetas[\[Theta],\[Phi],\[Theta]a,0], Assumptions->{\[Theta]>0, \[Phi]>0, \[Theta]a>0, \[Phi]a>0}]]
aniyx = Animate[RevolutionPlot3D[Ixrplot[\[Theta],\[Phi],\[Theta]a,0],{\[Theta],0,\[Pi]/2},{\[Phi],0,2*\[Pi]}, AxesLabel ->xyzlabl],{\[Theta]a,0,\[Pi]},AnimationRunning->False]
Print["z-polarized light = ", FullSimplify[Pzdetas[\[Theta],\[Phi],\[Theta]a,0], Assumptions->{\[Theta]>0, \[Phi]>0, \[Theta]a>0, \[Phi]a>0}]]
aniyz = Animate[RevolutionPlot3D[Izrplot[\[Theta],\[Phi],\[Theta]a,0],{\[Theta],0,\[Pi]/2},{\[Phi],0,2*\[Pi]}, AxesLabel ->xyzlabl],{\[Theta]a,0,\[Pi]},AnimationRunning->False]
(*Rotations about the z-axis*)
Print["---------------------------"]
Print["Rotation about the z-axis"]
Print["x-polarized light = ", FullSimplify[Pxdetas[\[Theta],\[Phi],\[Pi]/2,\[Phi]a], Assumptions->{\[Theta]>0, \[Phi]>0, \[Theta]a>0, \[Phi]a>0}]]
anizx = Animate[RevolutionPlot3D[Ixrplot[\[Theta],\[Phi],\[Pi]/2,\[Phi]a],{\[Theta],0,\[Pi]/2},{\[Phi],0,2*\[Pi]}, AxesLabel ->xyzlabl],{\[Phi]a,0,\[Pi]},AnimationRunning->False]
Print["z-polarized light = ", FullSimplify[Pzdetas[\[Theta],\[Phi],\[Pi]/2,\[Phi]a], Assumptions->{\[Theta]>0, \[Phi]>0, \[Theta]a>0, \[Phi]a>0}]]
anizz = Animate[RevolutionPlot3D[Izrplot[\[Theta],\[Phi],\[Pi]/2,\[Phi]a],{\[Theta],0,\[Pi]/2},{\[Phi],0,2*\[Pi]}, AxesLabel ->xyzlabl],{\[Phi]a,0,\[Pi]},AnimationRunning->False]


c1
\[Theta]1
\[Phi]1
SphericalHarmonicY[0,0, \[Theta], \[Phi]]
fr[mr[c1,\[Theta]1,\[Phi]1],r,\[Theta],\[Phi]]
Integrate[Integrate[Sin[\[Theta]]*((2*Sqrt[\[Pi]])^(-1)*SphericalHarmonicY[0,0, \[Theta], \[Phi]]+fr[mr[c1,\[Theta]1,\[Phi]1],r,\[Theta],\[Phi]]),{\[Theta],0,\[Pi]}],{\[Phi],0,2*\[Pi]}]
Pxdetas[\[Theta],\[Phi],\[Theta]a,\[Pi]/2]
Ixrplot[\[Theta],\[Phi],\[Theta]a,\[Pi]/2]

Integrate[Integrate[Sin[\[Theta]]*SphericalHarmonicY[0,0, \[Theta], \[Phi]]^2,{\[Theta],0,\[Pi]}],{\[Phi],0,2*\[Pi]}]
Integrate[Integrate[Sin[\[Theta]]*SphericalHarmonicY[1,0, \[Theta], \[Phi]]^2,{\[Theta],0,\[Pi]}],{\[Phi],0,2*\[Pi]}]

FullSimplify[Simplify[(Conjugate[Ersc[\[Theta],\[Phi],\[Theta]1,\[Phi]1]]*Ersc[\[Theta],\[Phi],\[Theta]1,\[Phi]1]), Assumptions->asyassumptions]]


SphericalHarmonicY[0,0, \[Theta], \[Phi]]
